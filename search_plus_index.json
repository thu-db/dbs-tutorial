[{"url":"./","title":"实验简介","level":"1.1","keywords":[],"body":"数据库系统概论实验 这里是文档的首页。 "},{"url":"honkit.html","title":"honkit 演示","level":"1.2","keywords":[],"body":"honkit 演示 markdown basic 语法均支持，见 https://www.markdownguide.org/basic-syntax/ 此外有以下插件： alerts [info] 信息标题 这里是一些 info 级信息 注意文件里要空一行 分隔 [warning] 信息标题 这里是一些 warning 级信息 分隔 [danger] 信息标题 这里是一些 danger 级信息 分隔 [success] 信息标题 这里是一些 success 级信息 注意如果没有上面的“分隔”将会出现渲染bug，导致它们被连起来 chapter-fold 打开某个子目录时，其他展开的父目录会自动折叠，已自动生效。 click-reveal Click to show 这就是 click-reveal 插件的效果。 code 为代码块增加行号以及“复制”按钮，已自动生效。 codeblock-label 这可以给代码块添加 label，一般用于加文件名。 main.cpp #include <stdio.h> int main() { printf(\"hello world!\\n\"); return 0; } expandable-chapters-interactive 实现子目录折叠/展开效果，已自动生效。 intopic-toc 在一页内的右上角生成目录，已自动生效。 katex-pro 内联公式： 2≈1.414\\sqrt{2} \\approx 1.4142​≈1.414 公式块： 3≈1.7324=2... \\sqrt{3} \\approx 1.732 \\\\ \\sqrt{4} = 2 \\\\ ... 3​≈1.7324​=2... search-plus 左上角的搜索插件优化，已自动生效。 todo 用于支持 markdown 扩展语法的 checklist [ ] 未实现 1 [ ] 未实现 2 [ ] 未实现 2-1 [x] 已实现 2-2 [x] 已实现 3 [x] 已实现 4 [x] 已实现 4-1 [x] 已实现 4-2 "},{"url":"chapter-0/intro.html","title":"介绍","level":"1.3.1","keywords":[],"body":"Welcome to introduction of Database System "},{"url":"chapter-1/intro.html","title":"介绍","level":"1.4.1","keywords":[],"body":""},{"url":"chapter-2/intro.html","title":"2.1 记录管理模块概述","level":"1.5.1","keywords":[],"body":"2.1 记录管理模块概述 数据库文件布局 可以在根目录下创建base和global两个目录：global目录中存储一些全局的系统表，如：数据库名和数据库ID的对应关系 (pg_database)。在base目录中，每个数据库对应一个子目录，子目录下也可以有一些系统表，如：关系 (包括表、索引) 名和关系ID的对应关系 (pg_class)。子目录下的表和索引都存储在单独的文件中，子目录和文件都以其ID命名。 文件的组织结构 为提高存储空间利用效率和管理的灵活性，文件被划分为页面 (如：4KB) 的集合，每个页面有唯一的标识符，如：文件内字节序列以页面大小为单位从前向后标记为0号页、1号页、2号页...页面的数据区被划分为一个个插槽，每个插槽中放置一条记录。这样，<文件路径，页号，槽号> 就与记录构成了一一对应的关系。 表的元数据 表的元数据包括表的列数、各列的数据类型和长度、表的页数、约束 (检查约束、唯一约束、主键约束、外键约束) 等信息，可以在数据库目录下创建系统表存储 (参考PostgreSQL的系统表)，简单的话也可以存储在表的前几页。 记录相关操作 记录的序列化和反序列化。在字节序列和一条记录间相互转换。 访问记录。根据数据库名和表名确定文件路径，根据页号和槽号找到记录的位置，通过反序列化解读出记录的内容。 插入记录。先找到空闲空间，再插入记录的序列化表示；如果没有空闲空间可能需要向缓存管理模块申请新页。 删除记录。先找到记录的位置，再将其删除；产生的碎片空闲空间视情况合并。 更新记录。对于定长记录来说，物理组织结构不变；对于变长记录来说，与删除后插入类似。 "},{"url":"chapter-2/fixed.html","title":"2.2 记录页面的设计模式-定长记录","level":"1.5.2","keywords":[],"body":"2.2 记录页面的设计模式-定长记录 记录存储格式 对于定长记录来说，记录的各列属性具有固定的长度，所以可以通过如下格式储存： NULL位图 各列数据 前者长度为 ⌈列数/8⌉ 字节，即每列一位储存该列是否为空；后者长度为各列长度之和。在解读时，记录的列数以及各列长度属于表的元数据。 页面布局 可以将页 (如：4KB) 划分为页头 (如：64B) 和数据两部分，后者可以按照记录长度划分为一个个槽,并在页头使用位图储存每个槽是否空闲。在插入记录寻找空闲槽时，只需要对位图进行处理；在删除记录时要对位图进行维护。在根据槽号访问记录时还需要记录的长度，该信息可以存储在页头，也可以由表的各列长度计算得到。 空闲空间管理 由于记录长度固定，所以只需要区分页面是否有空闲槽即可。可以维护两个链表分别由空闲页和满页组成，邻居页号可以在页头中存储，链表头页号可以作为表的元数据存储。 "},{"url":"chapter-2/variable.html","title":"2.3 记录页面的设计模式-变长记录","level":"1.5.3","keywords":[],"body":"2.3 记录页面的设计模式-变长记录 记录储存格式 可以以如下格式存储变长记录： NULL位图 定长数据 可变列的偏移数组 变长数据 NULL位图和定长数据部分与定长记录相同；可变列偏移数组的长度为 2字节*可变列数，从而在变长部分区分出各可变列的数据。 页面布局 页头需要存储槽容量 (有效槽+无效槽总数) 辅助解读页面字节序列，还需要存储空闲空间的字节偏移量和空闲字节数目便于空闲空间管理。解读页面还需要定长部分 (NULL位图+定长数据) 长度、可变列数目等信息，可以保存在页头，也可由表的元数据推算得到。 页身从前向后存储数据，从后向前存储槽目录，槽目录存储记录的字节偏移量。槽目录可以每2字节对应从0开始的自然数槽号，这样在通过槽号访问某槽时只需要O(1)时间，但在插入记录时最好在槽目录中从后向前优先利用无效槽号；也可以在槽目录中只存储有效槽号，不过在通过槽号访问某槽时需要遍历槽目录。 删除记录时可能产生碎片空闲空间，在数据量较小时不处理也无妨。在真实数据库中会有程序定期清理碎片空间，使页内空闲空间尽量连续。 空闲空间管理 链表 与定长记录类似，页面的空闲空间最大为 4096-64 字节，可以按照一定字节数 (如：32字节) 为单位将空闲空间大小分成若干个级别，每一级别维护一个链表。 页目录 可以保留一些页作为页目录而不作为数据页，页目录之间通过链表相连；每个页目录记录若干页的空闲空间大小。 大根堆二叉树 可以为每个表创建一个名为\"表ID_fsm\"的文件管理表的空闲空间。每个FSM页内为一棵大根堆二叉树，叶节点记录某页的空闲空间大小 (也可以将空闲空间大小分成256个级别，使每个节点仅占用1B)，非叶节点记录两个孩子中的较大值。这样，在需要一定空闲空间大小时，仅比较根节点即可判断表内是否有页面满足要求，然后沿二叉树逐级比较向下直到叶节点，即可找到合适的空闲页面。 如果页面较多，可以构建多级FSM页，高级FSM页的叶节点对应低级FSM页的根节点，且它们具有相同的值。 假设每个页面数据区大小为10B，则每个页面内可以构建出有4个叶节点的满二叉树；假设共有3级FSM页，例： 0 <-- page 0 at level 2 (root page) 0 <-- page 0 at level 1 0 <-- page 0 at level 0 1 <-- page 1 at level 0 2 <-- ... 3 1 <-- page 1 at level 1 4 5 6 7 8 9 假设命中了8号页内数据区偏移量为5的字节，由 n+⌊n/4+1⌋+⌊n/4^2+1⌋=8 解得 n=5，即8号页对应0级5号页；偏移量为5对应FSM页内1号叶节点。由 5*5+1=26 知对应表内26号页。 大根堆二叉树也可以参考PostgreSQL中相应说明。 "},{"url":"chapter-2/api.html","title":"2.4 对外提供的接口","level":"1.5.4","keywords":[],"body":"2.4 对外提供的接口 class RecordManager { public: RecordManager (FileManager &fm); // 构造函数 ~RecordManager (); // 析构函数 RC create_file (const char *file_name); // 创建文件 RC destroy_file (const char *file_name); // 删除文件 RC open_file (const char *file_name); // 通过缓存管理模块打开文件，并获取其fileID RC close_file (); // 关闭fileID对应文件 RC get_record (int page_id, int slot_id, char *&pData); // 通过页号和槽号访问记录后，相应字节序列可以通过pData访问 RC delete_record (int page_id, int slot_id); // 删除特定记录 RC insert_record (int page_id, int slot_id, const char *pData); // 将字节序列pData插入特定位置 RC update_record (page_id, slot_id, const char *pData); // 将特定位置记录更新为字节序列pData private: int fileID; }; "},{"url":"chapter-5/5_0_title.html","title":"标题","level":"1.8.1","keywords":[],"body":"Chapter 5: SQL to physical plan, parse and run "},{"url":"chapter-5/5_1_intro.html","title":"介绍","level":"1.8.2","keywords":[],"body":"5.1 解析器概述 在数据库系统中，解析器与执行器的作用紧密相关。当数据库系统需要执行一条查询执行时，需要通过结构化查询语言（SQL）描述这一查询过程传递给解析器。解析器的主要功能在于解析输入的SQL语句并将其转化为一套高效的物理执行计划交由执行器完成。内部的工作流程可以概括为3个部分： 词法语法分析：SQL语句到抽象语法树 逻辑优化：抽象语法树到逻辑计划树 物理优化：逻辑计划树到物理执行计划 经过词法和语法分析，SQL语句可以转化为抽象语法树，这一部分是编译原理课程的主要内容，期间不需要考虑数据库系统的设计和底层存储结构等任何与数据库系统实现相关的内容。所以这一部分不作为本课程关注的重点。根据我们所给出的语法文件，直接利用antlr的访问者模式可以比较轻松地完成这一步转化工作。 数据库解析器的特色在于其抽象语法树的后续处理过程，与编译器和解释器不同，此处不会结合系统和虚拟机特性转化为某种编码格式，而是需要结合数据库的一些统计信息和存储结构，在可能面临的很多种执行方案中规划出一套相对较优的实际物理执行计划并传递给执行器完成这一工作。这一部分包含了逻辑优化和物理优化两个过程，这一部分将成为各位同学思考的重点。 "},{"url":"chapter-5/5_2_sql.html","title":"SQL简介","level":"1.8.3","keywords":[],"body":"5.2 SQL语法简介 结构化查询语言(Structured Query Language)简称SQL，是一种数据库查询和程序设计语言，用于存取数据以及查询、更新和管理关系数据库系统；同时也是数据库脚本文件的扩展名。SQL是一门 ANSI 的标准计算机语言，用来访问和操作数据库系统。虽然作为一种数据库语言的基准，但是工业界数据库厂商大多都在SQL基准基础之上进行了一定程度的变化和拓展，导致了当今存在了大量不同版本的SQL文法规范。本次实验任务中，同学们仅需要重点关注于SQL语言中有关于数据操作语言（DML）和数据定义语言（DDL）的部分重点文法结构。 所有需要支持的文法已经在sql.g4文件中给出，文法对应的功能可以参阅文法手册。 由于SQL语句转抽象语法树的部分是编译原理课程已经充分研究的内容，所以第一个转化阶段不作为本次实验的重点内容，可以直接基于给出的文法文件利用antlr的访问者模式生成这一部分代码。解析器部分重点的实验内容为逻辑优化和物理优化的过程。 "},{"url":"chapter-5/5_3_logic.html","title":"逻辑优化","level":"1.8.4","keywords":[],"body":"5.3 逻辑优化：抽象语法树到逻辑计划树 查询优化器在逻辑优化阶段主要解决的问题是：如何找出SQL语句的等价变换形式，使SQL执行更高效；一般可以使用代数优化的方式完成这一过程。代数优化是通过关系代数中一些等价变化的方式调整原始的抽象语法树结构，使其变化为执行过程上更为简洁高效的逻辑计划树的形式。主要是一些基于规则的固定转化模式，逻辑优化过程基于如下的经验规则： 尽早进行选择运算，这样可以尽早降低运算数据的规模 合并同表的多个选择和投影运算，减少表的扫描次数 合并投影运算和其他双目运算（笛卡尔积，等值连接，并集差集），减少表的扫描次数 合并选择运算与笛卡尔积，避免直接计算笛卡尔积 提取公共子表达式，重复使用 基于上述的经验规则，常用的变化包括如下几类： 列裁剪：运算过程中仅保留必要的列，忽略其余列，降低数据传输开销。 谓词下推：将查询语句中的过滤表达式计算尽可能下推到距离数据源最近的地方，以尽早完成数据的过滤，进而显著地减少数据传输或计算的开销。 子查询合并：在语义等价条件下，多个子查询可以合并成一个子查询，这样多次表扫描，多次连接减少为单次表扫描和单次连接。 谓词重写：利用一些等价规则将IN、OR、LIKE、BETWEEN、AND等谓词进行等价转化。 条件化简：对于WHERE、HAVING等条件进行化简，例如常量传递和不等式变化等。 "},{"url":"chapter-5/5_4_physic.html","title":"物理优化","level":"1.8.5","keywords":[],"body":"5.4 物理优化：查询计划树到物理执行计划 代数优化改变查询语句中操作的次序和组合，但不涉及底层的存取路径。物理优化就是要选择高效合理的操作算法或存取路径，求得优化的查询计划，达到查询优化的目标。 查询优化器在物理优化阶段，主要解决的问题是： 从可选的单表扫描方式中，挑选什么样的单表扫描方式最优？ 对于两表连接，如何连接最优？ 对于多表连接，哪种连接顺序最优？ 对于多表连接，是否需要对每种连接顺序都探索？如果不全部探索，如何找到一种最优组合？ 可以选择基于规则的启发式优化或基于代价估算的优化。基于规则的启发式算法一般相对简单，优化效果一般但是速度较快，适合于解释执行的系统，查询优化和查询执行同时进行。编译执行的方式则是先进行编译优化后整体执行，查询优化和查询执行分离，此时使用基于代价估算的优化更容易获得更好的优化效果，但是可能会面临执行计划的选择空间很大，优化时间开销过高的问题。而将两者结合，先使用启发式算法限制候选空间，对于候选空间内的方案进行代价估计，这样可以在较短时间内获得一个相对较优的执行计划。 "},{"url":"chapter-5/5_5_interface.html","title":"接口说明","level":"1.8.6","keywords":[],"body":"5.5 对外提供的接口 pa::parse() // 词法语法分析：SQL语句到抽象语法树 pa::logic() // 逻辑优化：抽象语法树到逻辑计划树 pa::physic() // 物理优化：逻辑计划树到物理执行计划 "}]
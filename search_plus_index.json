[{"url":"./","title":"实验简介","level":"1.1","keywords":[],"body":"数据库系统概论实验 这里是文档的首页。 "},{"url":"honkit.html","title":"honkit 演示","level":"1.2","keywords":[],"body":"honkit 演示 markdown basic 语法均支持，见 https://www.markdownguide.org/basic-syntax/ 此外有以下插件： alerts [info] 信息标题 这里是一些 info 级信息 注意文件里要空一行 分隔 [warning] 信息标题 这里是一些 warning 级信息 分隔 [danger] 信息标题 这里是一些 danger 级信息 分隔 [success] 信息标题 这里是一些 success 级信息 注意如果没有上面的“分隔”将会出现渲染bug，导致它们被连起来 chapter-fold 打开某个子目录时，其他展开的父目录会自动折叠，已自动生效。 click-reveal Click to show 这就是 click-reveal 插件的效果。 code 为代码块增加行号以及“复制”按钮，已自动生效。 codeblock-label 这可以给代码块添加 label，一般用于加文件名。 main.cpp #include <stdio.h> int main() { printf(\"hello world!\\n\"); return 0; } expandable-chapters-interactive 实现子目录折叠/展开效果，已自动生效。 intopic-toc 在一页内的右上角生成目录，已自动生效。 katex-pro 内联公式： 2≈1.414\\sqrt{2} \\approx 1.4142​≈1.414 公式块： 3≈1.7324=2... \\sqrt{3} \\approx 1.732 \\\\ \\sqrt{4} = 2 \\\\ ... 3​≈1.7324​=2... search-plus 左上角的搜索插件优化，已自动生效。 todo 用于支持 markdown 扩展语法的 checklist [ ] 未实现 1 [ ] 未实现 2 [ ] 未实现 2-1 [x] 已实现 2-2 [x] 已实现 3 [x] 已实现 4 [x] 已实现 4-1 [x] 已实现 4-2 "},{"url":"chapter-0/intro.html","title":"介绍","level":"1.3.1","keywords":[],"body":"Welcome to introduction of Database System "},{"url":"chapter-1/intro.html","title":"介绍","level":"1.4.1","keywords":[],"body":""},{"url":"chapter-2/intro.html","title":"2.1 记录管理模块概述","level":"1.5.1","keywords":[],"body":"2.1 记录管理模块概述 数据库文件布局 可以在根目录下创建base和global两个目录：global目录中存储一些全局的系统表，如：数据库名和数据库ID的对应关系 (pg_database)。在base目录中，每个数据库对应一个子目录，子目录下也可以有一些系统表，如：关系 (包括表、索引) 名和关系ID的对应关系 (pg_class)。子目录下的表和索引都存储在单独的文件中，子目录和文件都以其ID命名。 文件的组织结构 为提高存储空间利用效率和管理的灵活性，文件被划分为页面 (如：4KB) 的集合，每个页面有唯一的标识符，如：文件内字节序列以页面大小为单位从前向后标记为0号页、1号页、2号页...页面的数据区被划分为一个个插槽，每个插槽中放置一条记录。这样，<文件路径，页号，槽号> 就与记录构成了一一对应的关系。 表的元数据 表的元数据包括表的列数、各列的数据类型和长度、表的页数、约束 (检查约束、唯一约束、主键约束、外键约束) 等信息，可以在数据库目录下创建系统表存储 (参考PostgreSQL的系统表)，简单的话也可以存储在表的前几页。 记录相关操作 记录的序列化和反序列化。在字节序列和一条记录间相互转换。 访问记录。根据数据库名和表名确定文件路径，根据页号和槽号找到记录的位置，通过反序列化解读出记录的内容。 插入记录。先找到空闲空间，再插入记录的序列化表示；如果没有空闲空间可能需要向缓存管理模块申请新页。 删除记录。先找到记录的位置，再将其删除；产生的碎片空闲空间视情况合并。 更新记录。对于定长记录来说，物理组织结构不变；对于变长记录来说，与删除后插入类似。 "},{"url":"chapter-2/fixed.html","title":"2.2 记录页面的设计模式-定长记录","level":"1.5.2","keywords":[],"body":"2.2 记录页面的设计模式-定长记录 记录存储格式 对于定长记录来说，记录的各列属性具有固定的长度，所以可以通过如下格式储存： NULL位图 各列数据 前者长度为 ⌈列数/8⌉ 字节，即每列一位储存该列是否为空；后者长度为各列长度之和。在解读时，记录的列数以及各列长度属于表的元数据。 页面布局 可以将页 (如：4KB) 划分为页头 (如：64B) 和数据两部分，后者可以按照记录长度划分为一个个槽,并在页头使用位图储存每个槽是否空闲。在插入记录寻找空闲槽时，只需要对位图进行处理；在删除记录时要对位图进行维护。在根据槽号访问记录时还需要记录的长度，该信息可以存储在页头，也可以由表的各列长度计算得到。 空闲空间管理 由于记录长度固定，所以只需要区分页面是否有空闲槽即可。可以维护两个链表分别由空闲页和满页组成，邻居页号可以在页头中存储，链表头页号可以作为表的元数据存储。 "},{"url":"chapter-2/variable.html","title":"2.3 记录页面的设计模式-变长记录","level":"1.5.3","keywords":[],"body":"2.3 记录页面的设计模式-变长记录 记录储存格式 可以以如下格式存储变长记录： NULL位图 定长数据 可变列的偏移数组 变长数据 NULL位图和定长数据部分与定长记录相同；可变列偏移数组的长度为 2字节*可变列数，从而在变长部分区分出各可变列的数据。 页面布局 页头需要存储槽容量 (有效槽+无效槽总数) 辅助解读页面字节序列，还需要存储空闲空间的字节偏移量和空闲字节数目便于空闲空间管理。解读页面还需要定长部分 (NULL位图+定长数据) 长度、可变列数目等信息，可以保存在页头，也可由表的元数据推算得到。 页身从前向后存储数据，从后向前存储槽目录，槽目录存储记录的字节偏移量。槽目录可以每2字节对应从0开始的自然数槽号，这样在通过槽号访问某槽时只需要O(1)时间，但在插入记录时最好在槽目录中从后向前优先利用无效槽号；也可以在槽目录中只存储有效槽号，不过在通过槽号访问某槽时需要遍历槽目录。 删除记录时可能产生碎片空闲空间，在数据量较小时不处理也无妨。在真实数据库中会有程序定期清理碎片空间，使页内空闲空间尽量连续。 空闲空间管理 链表 与定长记录类似，页面的空闲空间最大为 4096-64 字节，可以按照一定字节数 (如：32字节) 为单位将空闲空间大小分成若干个级别，每一级别维护一个链表。 页目录 可以保留一些页作为页目录而不作为数据页，页目录之间通过链表相连；每个页目录记录若干页的空闲空间大小。 大根堆二叉树 可以为每个表创建一个名为\"表ID_fsm\"的文件管理表的空闲空间。每个FSM页内为一棵大根堆二叉树，叶节点记录某页的空闲空间大小 (也可以将空闲空间大小分成256个级别，使每个节点仅占用1B)，非叶节点记录两个孩子中的较大值。这样，在需要一定空闲空间大小时，仅比较根节点即可判断表内是否有页面满足要求，然后沿二叉树逐级比较向下直到叶节点，即可找到合适的空闲页面。 如果页面较多，可以构建多级FSM页，高级FSM页的叶节点对应低级FSM页的根节点，且它们具有相同的值。 假设每个页面数据区大小为10B，则每个页面内可以构建出有4个叶节点的满二叉树；假设共有3级FSM页，例： 0 <-- page 0 at level 2 (root page) 0 <-- page 0 at level 1 0 <-- page 0 at level 0 1 <-- page 1 at level 0 2 <-- ... 3 1 <-- page 1 at level 1 4 5 6 7 8 9 假设命中了8号页内数据区偏移量为5的字节，由 n+⌊n/4+1⌋+⌊n/4^2+1⌋=8 解得 n=5，即8号页对应0级5号页；偏移量为5对应FSM页内1号叶节点。由 5*5+1=26 知对应表内26号页。 大根堆二叉树也可以参考PostgreSQL中相应说明。 "},{"url":"chapter-2/api.html","title":"2.4 对外提供的接口","level":"1.5.4","keywords":[],"body":"2.4 对外提供的接口 class RecordManager { public: RecordManager (FileManager &fm); // 构造函数 ~RecordManager (); // 析构函数 RC create_file (const char *file_name); // 创建文件 RC destroy_file (const char *file_name); // 删除文件 RC open_file (const char *file_name); // 通过缓存管理模块打开文件，并获取其fileID RC close_file (); // 关闭fileID对应文件 RC get_record (int page_id, int slot_id, char *&pData); // 通过页号和槽号访问记录后，相应字节序列可以通过pData访问 RC delete_record (int page_id, int slot_id); // 删除特定记录 RC insert_record (int page_id, int slot_id, const char *pData); // 将字节序列pData插入特定位置 RC update_record (page_id, slot_id, const char *pData); // 将特定位置记录更新为字节序列pData private: int fileID; }; "},{"url":"chapter-4/4-1-overview.html","title":"4.1 概述","level":"1.7.1","keywords":[],"body":"4.1 概述 查询处理指的是将查询语句转化为查询结果的过程，主要包含三个步骤： 解析器对查询语句进行语法分析，转化为语法树。 优化器首先将语法树转化为关系代数表达式树，我们将其称为逻辑查询计划树。进一步，根据数据的统计信息(如表的大小、是否有索引等)，为逻辑查询的每一步指定操作的顺序、使用的算法、访问数据的方式等，转化为物理查询计划树。 执行器在数据库上执行查询计划，并返回查询结果。 下图展示了一条 SQL 语句和其对应的逻辑查询计划树，逻辑查询计划树每个节点表示一个关系代数运算。但是，每个关系代数运算存在不同的操作方式，如扫描表时是否使用索引，表的连接采用什么算法等。我们需要根据数据库的统计信息，如索引、记录数量等，为每个关系代数运算选择最优的算法。本章主要介绍扫描算法和连接算法。 "},{"url":"chapter-4/4-2-scan.html","title":"4.2 扫描算法","level":"1.7.2","keywords":[],"body":"4.2 扫描算法 表的扫描是物理查询计划中最基本的操作，如对于 SELECT * FROM A; 这样一条简单的 SQL 查询，我们只需要将表A扫描一遍，输出表A的所有记录即可。 而大部分情况下，查询会包含一个谓词，如 SELECT * FROM A WHERE a < 10，这时我们在扫描表A的同时，还需要判断表A的每条记录是否符合谓词条件。对于这类查询，表的扫描算法主要有两种： 顺序扫描 (Sequential Scan)。最基本的扫描算法，扫描一张表的所有记录，判断记录是否符合选择条件，符合则将其加入查询结果，不符合则丢弃。 索引扫描 (Index Scan)。如果选择条件对应的列上有索引，便可以利用索引来得到符合条件的记录，避免全表扫描的过程。 "},{"url":"chapter-4/4-3-join.html","title":"4.3 连接算法","level":"1.7.3","keywords":[],"body":"4.3 连接算法 连接运算是关系代数中一个重要操作，也往往是最耗时的操作。本节我们仅讨论两表连接算法，且仅讨论等值连接，即形如 SELECT * FROM A,B WHERE A.a=B.b 查询的连接算法。 嵌套循环连接 (Nested Loop Join) 嵌套循环连接是两表连接最基本的算法，算法描述如下： for each row r1 in t1 { for each row r2 in t2 { if r1, r2 satisfies join conditions join r1, r2 } } 嵌套循环连接存在多种改进方法，如数据库可以每次读取一个 block，减少 I/O 请求次数。考虑记录获取方式，即可得到基于块的嵌套循环连接算法 (Block Nested Loop Join)，算法描述如下： for each block b1 of t1 { if b1 not in memory read b1 block b1 into memory for each row r1 in block b1 { for each block b2 of t2 { if b2 not in memory read block b2 into memory for each row r2 in b2 { if r1, r2 satisfies join conditions join r1, r2 } } } } 此外，如果内表在连接属性上有索引，则可以利用索引加速内循环，得到基于索引的循环连接算法 (Index Nested Loop Join)，有效提高连接效率。 排序归并连接 (Sort-Merge Join) 先将要连接的两个表在连接属性上排序，随后对排序后的表进行连接，算法描述如下： sort t1, t2 on join keys cursor_1 <- t1, cursor_2 <- t2 while cursor_1 and cursor_2: if cursor_r < cursor_2: increment cursor_1 if cursor_1 > cursor_2: increment cursor_2 if cursor_1 == cursor_2: Join cursor_1, cursor_2 如果两张表在连接前已经在连接属性上排好序，则可以省去排序操作。此外，排序归并连接算法的输出结果也是在连接属性上排好序的，如果查询在连接属性上有 order by 子句，排序归并连接算法便可以直接给出有序结果。 哈希连接 (Hash Join) 对一张表进行哈希运算建立哈希表，哈希表的 key 为连接属性。对另一张表的每条记录，用哈希函数求得连接属性上的值，映射到哈希表上即可得到要连接的记录，算法描述如下： build hash table HT for t1 for each row r2 in t2: if h(r2) in HT: join t1, t2 哈希连接算法效率较高，算法复杂度为 O(T1+T2)O(T1+T2)O(T1+T2)​，T1T1T1​ 和 T2T2T2​ 分别表示两张表记录的个数。但是哈希连接仅支持等值连接，且哈希表需要占用较大的内存空间，如果哈希表大小超出内存空间限制，则需要将哈希表写入临时文件。 "},{"url":"chapter-4/4-4-execution.html","title":"4.4 查询执行","level":"1.7.4","keywords":[],"body":"4.4 查询执行 目前仅讨论了单个关系运算如何执行，下面需要研究如何执行包含多个运算的查询计划树。 物化 最简单直观的想法是自底向上执行查询计划树，依次执行每个算子，每次执行的临时结果存储到内存或磁盘上，下一个算子在临时结果的基础上继续进行，这种执行策略称为物化。 物化方法的策略简单，但会产生大量的中间结果，占据磁盘和内存空间，且查询过程中需要多次访问磁盘，效率较低。 流水线 执行查询计划的另一种方法是同时进行多个运算，一个运算产生的结果直接传递给使用这个结果的下一个运算，不需要将中间结果存储到磁盘，这种方法称为流水线。 流水线中的每个操作可以由一个迭代算子来实现，每个迭代算子提供 Init 和 Next 接口。调用 Init 后，每次调用 next 返回该操作输出的下一条结果。同时迭代算子自身需要维护迭代状态，使得每次调用 next 返回正确的结果。 "},{"url":"chapter-4/4-5-api.html","title":"4.5 对外提供的接口","level":"1.7.5","keywords":[],"body":"4.5 对外提供的接口 class AbstractExecutor { void Init() = 0; bool Next(RID *rid) = 0; } class SeqScanExecutor: AbstractExecutor { void Init(); bool Next(RID *rid); } class IndexScanExecutor: AbstractExecutor { void Init(); bool Next(RID *rid); } class NestedLoopJoinExecutor: AbstractExecutor { void Init(); bool Next(RID *rid); } class SortMergeJoinExecutor: AbstractExecutor { void Init(); bool Next(RID *rid); } class HashJoinExecutor: AbstractExecutor { void Init(); bool Next(RID *rid); } "},{"url":"chapter-5/5_0_title.html","title":"标题","level":"1.8.1","keywords":[],"body":"Chapter 5: SQL to physical plan, parse and run "},{"url":"chapter-5/5_1_intro.html","title":"介绍","level":"1.8.2","keywords":[],"body":"5.1 解析器概述 在数据库系统中，解析器与执行器的作用紧密相关。当数据库系统需要执行一条查询执行时，需要通过结构化查询语言（SQL）描述这一查询过程传递给解析器。解析器的主要功能在于解析输入的SQL语句并将其转化为一套高效的物理执行计划交由执行器完成。内部的工作流程可以概括为3个部分： 词法语法分析：SQL语句到抽象语法树 逻辑优化：抽象语法树到逻辑计划树 物理优化：逻辑计划树到物理执行计划 经过词法和语法分析，SQL语句可以转化为抽象语法树，这一部分是编译原理课程的主要内容，期间不需要考虑数据库系统的设计和底层存储结构等任何与数据库系统实现相关的内容。所以这一部分不作为本课程关注的重点。根据我们所给出的语法文件，直接利用antlr的访问者模式可以比较轻松地完成这一步转化工作。 数据库解析器的特色在于其抽象语法树的后续处理过程，与编译器和解释器不同，此处不会结合系统和虚拟机特性转化为某种编码格式，而是需要结合数据库的一些统计信息和存储结构，在可能面临的很多种执行方案中规划出一套相对较优的实际物理执行计划并传递给执行器完成这一工作。这一部分包含了逻辑优化和物理优化两个过程，这一部分将成为各位同学思考的重点。 "},{"url":"chapter-5/5_2_sql.html","title":"SQL简介","level":"1.8.3","keywords":[],"body":"5.2 SQL语法简介 结构化查询语言(Structured Query Language)简称SQL，是一种数据库查询和程序设计语言，用于存取数据以及查询、更新和管理关系数据库系统；同时也是数据库脚本文件的扩展名。SQL是一门 ANSI 的标准计算机语言，用来访问和操作数据库系统。虽然作为一种数据库语言的基准，但是工业界数据库厂商大多都在SQL基准基础之上进行了一定程度的变化和拓展，导致了当今存在了大量不同版本的SQL文法规范。本次实验任务中，同学们仅需要重点关注于SQL语言中有关于数据操作语言（DML）和数据定义语言（DDL）的部分重点文法结构。 所有需要支持的文法已经在sql.g4文件中给出，文法对应的功能可以参阅文法手册。 由于SQL语句转抽象语法树的部分是编译原理课程已经充分研究的内容，所以第一个转化阶段不作为本次实验的重点内容，可以直接基于给出的文法文件利用antlr的访问者模式生成这一部分代码。解析器部分重点的实验内容为逻辑优化和物理优化的过程。 "},{"url":"chapter-5/5_3_logic.html","title":"逻辑优化","level":"1.8.4","keywords":[],"body":"5.3 逻辑优化：抽象语法树到逻辑计划树 查询优化器在逻辑优化阶段主要解决的问题是：如何找出SQL语句的等价变换形式，使SQL执行更高效；一般可以使用代数优化的方式完成这一过程。代数优化是通过关系代数中一些等价变化的方式调整原始的抽象语法树结构，使其变化为执行过程上更为简洁高效的逻辑计划树的形式。主要是一些基于规则的固定转化模式，逻辑优化过程基于如下的经验规则： 尽早进行选择运算，这样可以尽早降低运算数据的规模 合并同表的多个选择和投影运算，减少表的扫描次数 合并投影运算和其他双目运算（笛卡尔积，等值连接，并集差集），减少表的扫描次数 合并选择运算与笛卡尔积，避免直接计算笛卡尔积 提取公共子表达式，重复使用 基于上述的经验规则，常用的变化包括如下几类： 列裁剪：运算过程中仅保留必要的列，忽略其余列，降低数据传输开销。 谓词下推：将查询语句中的过滤表达式计算尽可能下推到距离数据源最近的地方，以尽早完成数据的过滤，进而显著地减少数据传输或计算的开销。 子查询合并：在语义等价条件下，多个子查询可以合并成一个子查询，这样多次表扫描，多次连接减少为单次表扫描和单次连接。 谓词重写：利用一些等价规则将IN、OR、LIKE、BETWEEN、AND等谓词进行等价转化。 条件化简：对于WHERE、HAVING等条件进行化简，例如常量传递和不等式变化等。 "},{"url":"chapter-5/5_4_physic.html","title":"物理优化","level":"1.8.5","keywords":[],"body":"5.4 物理优化：查询计划树到物理执行计划 代数优化改变查询语句中操作的次序和组合，但不涉及底层的存取路径。物理优化就是要选择高效合理的操作算法或存取路径，求得优化的查询计划，达到查询优化的目标。 查询优化器在物理优化阶段，主要解决的问题是： 从可选的单表扫描方式中，挑选什么样的单表扫描方式最优？ 对于两表连接，如何连接最优？ 对于多表连接，哪种连接顺序最优？ 对于多表连接，是否需要对每种连接顺序都探索？如果不全部探索，如何找到一种最优组合？ 可以选择基于规则的启发式优化或基于代价估算的优化。基于规则的启发式算法一般相对简单，优化效果一般但是速度较快，适合于解释执行的系统，查询优化和查询执行同时进行。编译执行的方式则是先进行编译优化后整体执行，查询优化和查询执行分离，此时使用基于代价估算的优化更容易获得更好的优化效果，但是可能会面临执行计划的选择空间很大，优化时间开销过高的问题。而将两者结合，先使用启发式算法限制候选空间，对于候选空间内的方案进行代价估计，这样可以在较短时间内获得一个相对较优的执行计划。 "},{"url":"chapter-5/5_5_interface.html","title":"接口说明","level":"1.8.6","keywords":[],"body":"5.5 对外提供的接口 pa::parse() // 词法语法分析：SQL语句到抽象语法树 pa::logic() // 逻辑优化：抽象语法树到逻辑计划树 pa::physic() // 物理优化：逻辑计划树到物理执行计划 "}]
[{"url":"./","title":"实验简介","level":"1.1","keywords":[],"body":"数据库系统概论实验 这里是文档的首页。 评论功能有点小 bug，切换页面后无法加载出评论，如有需要刷新网页即可。 本文档最后发布于 8/25/2021, 10:00:52 "},{"url":"honkit.html","title":"honkit 演示","level":"1.2","keywords":[],"body":"honkit 演示 markdown basic 语法均支持，见 https://www.markdownguide.org/basic-syntax/ 此外有以下插件： alerts [info] 信息标题 这里是一些 info 级信息 注意文件里要空一行 分隔 [warning] 信息标题 这里是一些 warning 级信息 分隔 [danger] 信息标题 这里是一些 danger 级信息 分隔 [success] 信息标题 这里是一些 success 级信息 注意如果没有上面的“分隔”将会出现渲染bug，导致它们被连起来 chapter-fold 打开某个子目录时，其他展开的父目录会自动折叠，已自动生效。 click-reveal Click to show 这就是 click-reveal 插件的效果。 code 为代码块增加行号以及“复制”按钮，已自动生效。 codeblock-label 这可以给代码块添加 label，一般用于加文件名。 main.cpp #include <stdio.h> int main() { printf(\"hello world!\\n\"); return 0; } expandable-chapters-interactive 实现子目录折叠/展开效果，已自动生效。 intopic-toc 在一页内的右上角生成目录，已自动生效。 katex-pro 内联公式： 2≈1.414\\sqrt{2} \\approx 1.4142​≈1.414 公式块： 3≈1.7324=2... \\sqrt{3} \\approx 1.732 \\\\ \\sqrt{4} = 2 \\\\ ... 3​≈1.7324​=2... search-plus 左上角的搜索插件优化，已自动生效。 todo 用于支持 markdown 扩展语法的 checklist [ ] 未实现 1 [ ] 未实现 2 [ ] 未实现 2-1 [x] 已实现 2-2 [x] 已实现 3 [x] 已实现 4 [x] 已实现 4-1 [x] 已实现 4-2 "},{"url":"chapter-0/intro.html","title":"介绍","level":"1.3.1","keywords":[],"body":"Welcome to introduction of Database System last update at: 8/25/2021, 10:00:52 author: 饶淙元 var discussion = document.getElementById('my-comment'); var script = document.createElement('script'); script.src = 'https://utteranc.es/client.js'; script.setAttribute('repo', 'thu-db/dbs-tutorial'); script.setAttribute('issue-term', \"pathname\"); script.setAttribute('theme', 'github-light'); script.setAttribute('crossorigin', 'anonymous'); discussion.appendChild(script); "},{"url":"chapter-1/intro.html","title":"介绍","level":"1.4.1","keywords":[],"body":"模块概述 这个模块属于是数据库的底层设施，甚至不算数据库的一部分，在课改前的大作业中是没有算进需要实现的几个模块之一的。但助教商讨认为，了解本模块对于理解数据库的上层实现有重要意义，因此我们依然提供了往年祖传的实现，但也进行了详细讲解，以便有需要的同学按照教程自行实现。 last update at: 8/25/2021, 10:00:52 author: 饶淙元 var discussion = document.getElementById('my-comment'); var script = document.createElement('script'); script.src = 'https://utteranc.es/client.js'; script.setAttribute('repo', 'thu-db/dbs-tutorial'); script.setAttribute('issue-term', \"pathname\"); script.setAttribute('theme', 'github-light'); script.setAttribute('crossorigin', 'anonymous'); discussion.appendChild(script); "},{"url":"chapter-2/intro.html","title":"2.1 记录管理模块概述","level":"1.5.1","keywords":[],"body":"2.1 记录管理模块概述 数据库文件布局 可以在根目录下创建base和global两个目录：global目录中存储一些全局的系统表，如：数据库名和数据库ID的对应关系 (pg_database)。在base目录中，每个数据库对应一个子目录，子目录下也可以有一些系统表，如：关系 (包括表、索引) 名和关系ID的对应关系 (pg_class)。子目录下的表和索引都存储在单独的文件中，子目录和文件都以其ID命名。 文件的组织结构 为提高存储空间利用效率和管理的灵活性，文件被划分为页面 (如：4KB) 的集合，每个页面有唯一的标识符，如：文件内字节序列以页面大小为单位从前向后标记为0号页、1号页、2号页...页面的数据区被划分为一个个插槽，每个插槽中放置一条记录。这样，<文件路径，页号，槽号> 就与记录构成了一一对应的关系。某条记录的页号和槽号建议不要轻易修改，否则相关的索引也要修改。 表的元数据 表的元数据包括表的列数、各列的数据类型和长度、表的页数、约束 (检查约束、唯一约束、主键约束、外键约束) 等信息，可以在数据库目录下创建系统表存储 (参考PostgreSQL的系统表)，简单的话也可以存储在表的前几页。 记录相关操作 记录的序列化和反序列化。在字节序列和一条记录间相互转换。 访问记录。根据数据库名和表名确定文件路径，根据页号和槽号找到记录的位置，通过反序列化解读出记录的内容。 插入记录。先找到空闲空间，再插入记录的序列化表示；如果没有空闲空间可能需要向缓存管理模块申请新页。 删除记录。先找到记录的位置，再将其删除；产生的碎片空闲空间视情况合并。 更新记录。对于定长记录来说，物理组织结构不变；对于变长记录来说，与删除后插入类似。 last update at: 8/25/2021, 10:00:52 author: 孙昭言 var discussion = document.getElementById('my-comment'); var script = document.createElement('script'); script.src = 'https://utteranc.es/client.js'; script.setAttribute('repo', 'thu-db/dbs-tutorial'); script.setAttribute('issue-term', \"pathname\"); script.setAttribute('theme', 'github-light'); script.setAttribute('crossorigin', 'anonymous'); discussion.appendChild(script); "},{"url":"chapter-2/fixed.html","title":"2.2 记录页面的设计模式-定长记录","level":"1.5.2","keywords":[],"body":"2.2 记录页面的设计模式-定长记录 记录存储格式 对于定长记录来说，记录的各列属性具有固定的长度，所以可以通过如下格式储存： NULL位图 各列数据 前者长度为 ⌈列数/8⌉ 字节，即每列一位储存该列是否为空；后者长度为各列长度之和。在解读时，记录的列数以及各列长度属于表的元数据。 页面布局 可以将页 (如：4KB) 划分为页头 (如：64B) 和数据两部分，后者可以按照记录长度划分为一个个槽,并在页头使用位图储存每个槽是否空闲。在插入记录寻找空闲槽时，只需要对位图进行处理；在删除记录时要对位图进行维护。在根据槽号访问记录时还需要记录的长度，该信息可以存储在页头，也可以由表的各列长度计算得到。 空闲空间管理 由于记录长度固定，所以只需要区分页面是否有空闲槽即可。可以维护两个链表分别由空闲页和满页组成，邻居页号可以在页头中存储，链表头页号可以作为表的元数据存储。 last update at: 8/25/2021, 10:00:52 author: 孙昭言 var discussion = document.getElementById('my-comment'); var script = document.createElement('script'); script.src = 'https://utteranc.es/client.js'; script.setAttribute('repo', 'thu-db/dbs-tutorial'); script.setAttribute('issue-term', \"pathname\"); script.setAttribute('theme', 'github-light'); script.setAttribute('crossorigin', 'anonymous'); discussion.appendChild(script); "},{"url":"chapter-2/variable.html","title":"2.3 记录页面的设计模式-变长记录","level":"1.5.3","keywords":[],"body":"2.3 记录页面的设计模式-变长记录 记录储存格式 可以以如下格式存储变长记录： NULL位图 定长数据 可变列的偏移数组 变长数据 NULL位图和定长数据部分与定长记录相同；可变列偏移数组的长度为 2字节*可变列数，从而在变长部分区分出各可变列的数据。 页面布局 页头需要存储槽容量 (有效槽+无效槽总数) 辅助解读页面字节序列，还需要存储空闲空间的字节偏移量和空闲字节数目便于空闲空间管理。解读页面还需要定长部分 (NULL位图+定长数据) 长度、可变列数目等信息，可以保存在页头，也可由表的元数据推算得到。 页身从前向后存储数据，从后向前存储槽目录，槽目录存储记录的字节偏移量。槽目录可以每2字节对应从0开始的自然数槽号，这样在通过槽号访问某槽时只需要O(1)时间，但在插入记录时最好在槽目录中从后向前优先利用无效槽号；也可以在槽目录中只存储有效槽号，不过在通过槽号访问某槽时需要遍历槽目录。某条记录的页号和槽号建议不要轻易修改，否则相关的索引也要修改。 删除记录时可能产生碎片空闲空间，在数据量较小时不处理也无妨。在真实数据库中会有程序定期清理碎片空间，使页内空闲空间尽量连续。 空闲空间管理 链表 与定长记录类似，页面的空闲空间最大为 4096-64 字节，可以按照一定字节数 (如：32字节) 为单位将空闲空间大小分成若干个级别，每一级别维护一个链表。 页目录 可以保留一些页作为页目录而不作为数据页，页目录之间通过链表相连；每个页目录记录若干页的空闲空间大小。 大根堆二叉树 可以为每个表创建一个名为\"表ID_fsm\"的文件管理表的空闲空间。每个FSM页内为一棵大根堆二叉树，叶节点记录某页的空闲空间大小 (也可以将空闲空间大小分成256个级别，使每个节点仅占用1B)，非叶节点记录两个孩子中的较大值。这样，在需要一定空闲空间大小时，仅比较根节点即可判断表内是否有页面满足要求，然后沿二叉树逐级比较向下直到叶节点，即可找到合适的空闲页面。 如果页面较多，可以构建多级FSM页，高级FSM页的叶节点对应低级FSM页的根节点，且它们具有相同的值。 假设每个页面数据区大小为10B，则每个页面内可以构建出有4个叶节点的满二叉树；假设共有3级FSM页，例： 0 <-- page 0 at level 2 (root page) 0 <-- page 0 at level 1 0 <-- page 0 at level 0 1 <-- page 1 at level 0 2 <-- ... 3 1 <-- page 1 at level 1 4 5 6 7 8 9 假设命中了8号页内数据区偏移量为5的字节，由 n+⌊n/4+1⌋+⌊n/4^2+1⌋=8 解得 n=5，即8号页对应0级5号页；偏移量为5对应FSM页内1号叶节点。由 5*5+1=26 知对应表内26号页。 大根堆二叉树也可以参考PostgreSQL中相应说明。 last update at: 8/25/2021, 10:00:52 author: 孙昭言 var discussion = document.getElementById('my-comment'); var script = document.createElement('script'); script.src = 'https://utteranc.es/client.js'; script.setAttribute('repo', 'thu-db/dbs-tutorial'); script.setAttribute('issue-term', \"pathname\"); script.setAttribute('theme', 'github-light'); script.setAttribute('crossorigin', 'anonymous'); discussion.appendChild(script); "},{"url":"chapter-2/api.html","title":"2.4 对外提供的接口","level":"1.5.4","keywords":[],"body":"2.4 对外提供的接口 class RecordManager { public: RecordManager (); // 构造函数 ~RecordManager (); // 析构函数 RC CreateFile (const char *fileName); // 创建文件 RC DestroyFile (const char *fileName); // 删除文件 RC OpenFile (const char *fileName); // 通过缓存管理模块打开文件，并获取其句柄 RC CloseFile (); // 关闭fileID对应文件 RC GetRecord (const RID &rid, char *&pData); // 通过页号和槽号访问记录后，相应字节序列可以通过pData访问 RC DeleteRecord (const RID &rid); // 删除特定记录 RC InsertRecord (const RID &rid, const char *pData); // 将字节序列pData插入特定位置 RC UpdateRecord (const RID &rid, const char *pData); // 将特定位置记录更新为字节序列pData }; last update at: 8/25/2021, 10:00:52 author: 孙昭言 var discussion = document.getElementById('my-comment'); var script = document.createElement('script'); script.src = 'https://utteranc.es/client.js'; script.setAttribute('repo', 'thu-db/dbs-tutorial'); script.setAttribute('issue-term', \"pathname\"); script.setAttribute('theme', 'github-light'); script.setAttribute('crossorigin', 'anonymous'); discussion.appendChild(script); "},{"url":"chapter-3/intro.html","title":"3.1 索引管理模块概述","level":"1.6.1","keywords":[],"body":"3.1 索引管理模块概述 索引是这样的数据结构：它以一个或多个属性的值为输入，并能快速地定位具有该值的记录的位置。索引的属性（组）称为查找键。由于索引是表的附加结构，当表的内容发生变化时，DBMS必须同步更新该表的索引。由此可见，索引虽然有助于提高查询性能，但是索引本身也会带来存储和维护开销。与表一样，一个索引结构同样存储在一个页式文件中。 本节内容对应教材《数据库系统设计与原理(第2版)》（冯建华等，清华大学出版社）第8章：索引和散列。 记录的组织方式 关系 (表、索引) 是记录的集合，如：(关键字, 表页号, 表页内槽号) 的对应关系可以作为索引的记录存储。记录在关系中可以有不同的组织方式： 堆文件组织：一条记录可以放在文件中的任何地方，只要那里有足够的空间存放这条记录，记录间不用考虑先后顺序的。第2节中说明的表按照这种方式组织。 顺序文件组织：记录根据其\"查找键\"的值顺序存储。顺序索引按照这种方式组织。 散列文件组织：在每条记录的某个/些属性上计算一个散列函数，根据散列的结果来确定将记录放到文件的哪个页面中。散列索引按照这种方式组织。 索引的元数据 索引的元数据与表的元数据基本相同，可以用相同的方式处理，不过要注意存储使用索引的表。 last update at: 8/25/2021, 10:00:52 author: 孙昭言 var discussion = document.getElementById('my-comment'); var script = document.createElement('script'); script.src = 'https://utteranc.es/client.js'; script.setAttribute('repo', 'thu-db/dbs-tutorial'); script.setAttribute('issue-term', \"pathname\"); script.setAttribute('theme', 'github-light'); script.setAttribute('crossorigin', 'anonymous'); discussion.appendChild(script); "},{"url":"chapter-3/btree.html","title":"3.2 索引结构-B树和B+树","level":"1.6.2","keywords":[],"body":"3.2 索引结构-B树和B+树 B树在先修课程《数据结构》中做过讲解，这里不再赘述。索引结构中我们重点介绍B+树。 B+树概述 m 阶B+树具有如下特征： 每个结点的关键字个数与孩子个数相等，所有非最下层的结点的关键字是对应子树上的最大关键字。 除根结点以外，每个内部结点的孩子数属于 [(m+1)/2, m]。 最下层结点（叶结点）包含了全部“键-值”对，叶结点可以按照键值从小到大连成单向或双向的链表。 在数据库索引中，每页作为一个结点，是否叶结点、叶结点链表等数据可以存储在页头中。非叶结点要存储若干个 (关键字, 孩子页号) 结构，叶结点要存储若干个 (关键字, 表页号, 表页内槽号) 结构，这种结构可以像表内一条记录一样存储。 查找 给定待查找的关键字，对每个结点找到不小于该关键字的第一项。从根结点开始对每个途经结点重复上述过程，并选择键值对应孩子页为下一个查找结点，从而在索引中找到该关键字的下界所在的叶结点。查找某个关键字范围 [a, b] 内的记录可以先找到关键字 a，然后沿叶结点链表顺序查找，直到某个叶结点存在大于b的关键字。 插入 给定待插入记录的关键字，可以插入到其下界所在的叶结点。如果叶结点最大键值改变，可能需要逐级更新父结点的键值。如果某结点发生上溢，则将其分裂为两个分支数相近的结点，都作为该结点父结点的子结点，父结点也要处理可能的上溢；如果该结点为根结点，则需要创建新的根结点作为父结点。 删除 给定某关键字（范围），查找其下界所在的叶结点，然后沿叶结点链表顺序扫描直到完成删除。如果叶结点最大键值改变，可能需要逐级更新父结点的键值。如果某结点发生下溢，如果其为根结点，其子结点在某些情况下可能成为新的根结点；如果其左/右兄弟有多余的孩子结点，可以过继给它；否则可以将其与左/右兄弟合并成一个结点，删除或更新父结点的关键字，父结点也要处理可能的下溢。 更新 查找给定关键字直到恰好匹配表页号和槽号完成更新，索引结构保持不变。 last update at: 8/25/2021, 10:00:52 author: 孙昭言 var discussion = document.getElementById('my-comment'); var script = document.createElement('script'); script.src = 'https://utteranc.es/client.js'; script.setAttribute('repo', 'thu-db/dbs-tutorial'); script.setAttribute('issue-term', \"pathname\"); script.setAttribute('theme', 'github-light'); script.setAttribute('crossorigin', 'anonymous'); discussion.appendChild(script); "},{"url":"chapter-3/ds.html","title":"3.3 更多的索引结构（阅读内容）","level":"1.6.3","keywords":[],"body":"3.3 更多的索引结构（阅读内容） 散列表 散列表的两个要素是散列函数和桶数组，相关知识在先修课程《数据结构》中做过讲解，这里不再赘述。散列表索引的桶数组存储在页式文件中。 静态散列表 桶的总数不变。i 号桶对应 i 号页，桶满后以链表的形式添加新页。 动态散列表 动态散列表可以根据记录总数调整桶的总数。其做出的改进如下： 增加了一个间接层，用一个指向页面的指针数组（桶地址表）而非页面数组来表示桶数组。 指针数组能动态增长，且数组长度总是2的幂，因此数组每增长一次，桶的数量就翻倍。 并非每个桶都单独拥有一个页面。如果多个桶的记录只需一个页面就能放下，那么这些桶可能共享一个页面，即多个桶指针指向同一个页面。 散列函数 h 为每个键计算出一个长度为N的二进制序列，但是在某一时刻，这个序列中只有前 i 位 (i≤N) 被使用，此时桶的数量为 2^i 个。 插入关键字为 K 的记录时，根据散列函数计算 h(K)，取出该二进制序列的前 i 位，并根据桶地址表找到桶数组中相对应的页面 j。如果页面已满，可能出现两种情况： 桶地址表中有多个表项指向该页面，此时不需要扩大桶地址表就能分裂页面。分配一个新的页面 n，调整桶地址表中原来指向页面 j 的表项，其中一半指向新创建的页面 n；重新散列页面j中的各条记录，将其分配到页面 j 或页面 n 中，并再次尝试插入新记录。如果插入失败，则需要继续进行页面分裂。 如果桶地址表中只有一个表项指向页面 j，此时分裂该页，需要使桶地址表的大小翻倍，以容纳由于分裂而产生的两个桶指针。桶地址表扩展后，原表中的每个表项都被两个表项替代，且这两个表项都包含和原始表项一样的指针，所以也应该有两个表项指向页面 j。此时，分配一个新的页面 n，并让第二个表项指向页面 n。将原页面j中的各条记录重新散列，根据前 i+1 位来确定该记录是放在页面 j 中还是页面 n 中，然后再次尝试插入新记录。如果插入失败，则需要继续进行页面分裂。 其它索引结构 非传统关系型数据库也会用到跳转表 (Skiplist)、布隆过滤 (Bloom Filter) 等数据结构，这些内容已经超出本课程范围。 last update at: 8/25/2021, 10:00:52 author: 孙昭言 var discussion = document.getElementById('my-comment'); var script = document.createElement('script'); script.src = 'https://utteranc.es/client.js'; script.setAttribute('repo', 'thu-db/dbs-tutorial'); script.setAttribute('issue-term', \"pathname\"); script.setAttribute('theme', 'github-light'); script.setAttribute('crossorigin', 'anonymous'); discussion.appendChild(script); "},{"url":"chapter-3/api.html","title":"3.4 对外提供的接口","level":"1.6.4","keywords":[],"body":"3.4 对外提供的接口 class IndexScan { public: IndexScan (); // 构造函数 ~IndexScan (); // 析构函数 RC GetNextEntry (RID &rid); // 类似于Python中的迭代器，不断调用获取下一个记录的位置 }; // 索引关键字只要求单列整型或浮点型 class IndexManager { public: IndexManager (); // 构造函数 ~IndexManager (); // 析构函数 RC CreateIndex (const char *fileName); // 创建索引 RC DestroyIndex (const char *fileName); // 删除索引 RC OpenIndex (const char *fileName); // 通过缓存管理模块打开索引，并获取其句柄 RC CloseIndex (); // 关闭索引 RC Search (double lowerBound, double upperBound, IndexScan &indexScan); // 查找某个范围内的记录，结果通过迭代器访问 RC DeleteRecord (double lowerBound, double upperBound); // 删除某个范围内的记录 RC InsertRecord (double key, const RID &rid); // 插入某个记录的位置 RC UpdateRecord (double oldKey, const RID &oldRid, double newKey, const RID &newRid); // 更新特定记录的关键字或位置 }; last update at: 8/25/2021, 10:00:52 author: 孙昭言 var discussion = document.getElementById('my-comment'); var script = document.createElement('script'); script.src = 'https://utteranc.es/client.js'; script.setAttribute('repo', 'thu-db/dbs-tutorial'); script.setAttribute('issue-term', \"pathname\"); script.setAttribute('theme', 'github-light'); script.setAttribute('crossorigin', 'anonymous'); discussion.appendChild(script); "},{"url":"chapter-4/4-1-overview.html","title":"4.1 概述","level":"1.7.1","keywords":[],"body":"4.1 概述 查询处理指的是将查询语句转化为查询结果的过程，主要包含三个步骤： 解析器对查询语句进行语法分析，转化为语法树。 优化器首先将语法树转化为关系代数表达式树，我们将其称为逻辑查询计划树。进一步，根据数据的统计信息(如表的大小、是否有索引等)，为逻辑查询的每一步指定操作的顺序、使用的算法、访问数据的方式等，转化为物理查询计划树。 执行器在数据库上执行查询计划，并返回查询结果。 下图展示了一条 SQL 语句和其对应的逻辑查询计划树，逻辑查询计划树每个节点表示一个关系代数运算。但是，每个关系代数运算存在不同的操作方式，如扫描表时是否使用索引，表的连接采用什么算法等。我们需要根据数据库的统计信息，如索引、记录数量等，为每个关系代数运算选择最优的算法。本章主要介绍扫描算法和连接算法。 last update at: 8/25/2021, 10:00:52 author: 李文博 var discussion = document.getElementById('my-comment'); var script = document.createElement('script'); script.src = 'https://utteranc.es/client.js'; script.setAttribute('repo', 'thu-db/dbs-tutorial'); script.setAttribute('issue-term', \"pathname\"); script.setAttribute('theme', 'github-light'); script.setAttribute('crossorigin', 'anonymous'); discussion.appendChild(script); "},{"url":"chapter-4/4-2-scan.html","title":"4.2 扫描算法","level":"1.7.2","keywords":[],"body":"4.2 扫描算法 表的扫描是物理查询计划中最基本的操作，如对于 SELECT * FROM A; 这样一条简单的 SQL 查询，我们只需要将表A扫描一遍，输出表A的所有记录即可。 而大部分情况下，查询会包含一个谓词，如 SELECT * FROM A WHERE a < 10，这时我们在扫描表A的同时，还需要判断表A的每条记录是否符合谓词条件。对于这类查询，表的扫描算法主要有两种： 顺序扫描 (Sequential Scan)。最基本的扫描算法，扫描一张表的所有记录，判断记录是否符合选择条件，符合则将其加入查询结果，不符合则丢弃。 索引扫描 (Index Scan)。如果选择条件对应的列上有索引，便可以利用索引来得到符合条件的记录，避免全表扫描的过程。 last update at: 8/25/2021, 10:00:52 author: 李文博 var discussion = document.getElementById('my-comment'); var script = document.createElement('script'); script.src = 'https://utteranc.es/client.js'; script.setAttribute('repo', 'thu-db/dbs-tutorial'); script.setAttribute('issue-term', \"pathname\"); script.setAttribute('theme', 'github-light'); script.setAttribute('crossorigin', 'anonymous'); discussion.appendChild(script); "},{"url":"chapter-4/4-3-join.html","title":"4.3 连接算法","level":"1.7.3","keywords":[],"body":"4.3 连接算法 连接运算是关系代数中一个重要操作，也往往是最耗时的操作。本节我们仅讨论两表连接算法，且仅讨论等值连接，即形如 SELECT * FROM A,B WHERE A.a=B.b 查询的连接算法。 嵌套循环连接 (Nested Loop Join) 嵌套循环连接是两表连接最基本的算法，算法描述如下： for each row r1 in t1 { for each row r2 in t2 { if r1, r2 satisfies join conditions join r1, r2 } } 嵌套循环连接存在多种改进方法，如数据库可以每次读取一个 block，减少 I/O 请求次数。考虑记录获取方式，即可得到基于块的嵌套循环连接算法 (Block Nested Loop Join)，算法描述如下： for each block b1 of t1 { if b1 not in memory read b1 block b1 into memory for each row r1 in block b1 { for each block b2 of t2 { if b2 not in memory read block b2 into memory for each row r2 in b2 { if r1, r2 satisfies join conditions join r1, r2 } } } } 此外，如果内表在连接属性上有索引，则可以利用索引加速内循环，得到基于索引的循环连接算法 (Index Nested Loop Join)，有效提高连接效率。 排序归并连接 (Sort-Merge Join) 先将要连接的两个表在连接属性上排序，随后对排序后的表进行连接，算法描述如下： sort t1, t2 on join keys cursor_1 <- t1, cursor_2 <- t2 while cursor_1 and cursor_2: if cursor_r < cursor_2: increment cursor_1 if cursor_1 > cursor_2: increment cursor_2 if cursor_1 == cursor_2: Join cursor_1, cursor_2 如果两张表在连接前已经在连接属性上排好序，则可以省去排序操作。此外，排序归并连接算法的输出结果也是在连接属性上排好序的，如果查询在连接属性上有 order by 子句，排序归并连接算法便可以直接给出有序结果。 哈希连接 (Hash Join) 对一张表进行哈希运算建立哈希表，哈希表的 key 为连接属性。对另一张表的每条记录，用哈希函数求得连接属性上的值，映射到哈希表上即可得到要连接的记录，算法描述如下： build hash table HT for t1 for each row r2 in t2: if h(r2) in HT: join t1, t2 哈希连接算法效率较高，算法复杂度为 O(T1+T2)O(T1+T2)O(T1+T2)​，T1T1T1​ 和 T2T2T2​ 分别表示两张表记录的个数。但是哈希连接仅支持等值连接，且哈希表需要占用较大的内存空间，如果哈希表大小超出内存空间限制，则需要将哈希表写入临时文件。 last update at: 8/25/2021, 10:00:52 author: 李文博 var discussion = document.getElementById('my-comment'); var script = document.createElement('script'); script.src = 'https://utteranc.es/client.js'; script.setAttribute('repo', 'thu-db/dbs-tutorial'); script.setAttribute('issue-term', \"pathname\"); script.setAttribute('theme', 'github-light'); script.setAttribute('crossorigin', 'anonymous'); discussion.appendChild(script); "},{"url":"chapter-4/4-4-execution.html","title":"4.4 查询执行","level":"1.7.4","keywords":[],"body":"4.4 查询执行 目前仅讨论了单个关系运算如何执行，下面需要研究如何执行包含多个运算的查询计划树。 物化 最简单直观的想法是自底向上执行查询计划树，依次执行每个算子，每次执行的临时结果存储到内存或磁盘上，下一个算子在临时结果的基础上继续进行，这种执行策略称为物化。 物化方法的策略简单，但会产生大量的中间结果，占据磁盘和内存空间，且查询过程中需要多次访问磁盘，效率较低。 流水线 执行查询计划的另一种方法是同时进行多个运算，一个运算产生的结果直接传递给使用这个结果的下一个运算，不需要将中间结果存储到磁盘，这种方法称为流水线。 流水线中的每个操作可以由一个迭代算子来实现，每个迭代算子提供 Init 和 Next 接口。调用 Init 后，每次调用 next 返回该操作输出的下一条结果。同时迭代算子自身需要维护迭代状态，使得每次调用 next 返回正确的结果。 last update at: 8/25/2021, 10:00:52 author: 李文博 var discussion = document.getElementById('my-comment'); var script = document.createElement('script'); script.src = 'https://utteranc.es/client.js'; script.setAttribute('repo', 'thu-db/dbs-tutorial'); script.setAttribute('issue-term', \"pathname\"); script.setAttribute('theme', 'github-light'); script.setAttribute('crossorigin', 'anonymous'); discussion.appendChild(script); "},{"url":"chapter-4/4-5-api.html","title":"4.5 对外提供的接口","level":"1.7.5","keywords":[],"body":"4.5 对外提供的接口 class AbstractExecutor { void Init() = 0; bool Next(RID *rid) = 0; } class SeqScanExecutor: AbstractExecutor { void Init(); bool Next(RID *rid); } class IndexScanExecutor: AbstractExecutor { void Init(); bool Next(RID *rid); } class NestedLoopJoinExecutor: AbstractExecutor { void Init(); bool Next(RID *rid); } class SortMergeJoinExecutor: AbstractExecutor { void Init(); bool Next(RID *rid); } class HashJoinExecutor: AbstractExecutor { void Init(); bool Next(RID *rid); } last update at: 8/25/2021, 10:00:52 author: 李文博 var discussion = document.getElementById('my-comment'); var script = document.createElement('script'); script.src = 'https://utteranc.es/client.js'; script.setAttribute('repo', 'thu-db/dbs-tutorial'); script.setAttribute('issue-term', \"pathname\"); script.setAttribute('theme', 'github-light'); script.setAttribute('crossorigin', 'anonymous'); discussion.appendChild(script); "},{"url":"chapter-5/5_0_title.html","title":"标题","level":"1.8.1","keywords":[],"body":"Chapter 5: SQL to physical plan, parse and run last update at: 8/25/2021, 10:00:52 author: 董昊文 var discussion = document.getElementById('my-comment'); var script = document.createElement('script'); script.src = 'https://utteranc.es/client.js'; script.setAttribute('repo', 'thu-db/dbs-tutorial'); script.setAttribute('issue-term', \"pathname\"); script.setAttribute('theme', 'github-light'); script.setAttribute('crossorigin', 'anonymous'); discussion.appendChild(script); "},{"url":"chapter-5/5_1_intro.html","title":"介绍","level":"1.8.2","keywords":[],"body":"5.1 解析器概述 在数据库系统中，解析器与执行器的作用紧密相关。当数据库系统需要执行一条查询执行时，需要通过结构化查询语言（SQL）描述这一查询过程传递给解析器。解析器的主要功能在于解析输入的SQL语句并将其转化为一套高效的物理执行计划交由执行器完成。内部的工作流程可以概括为3个部分： 词法语法分析：SQL语句到抽象语法树 逻辑优化：抽象语法树到逻辑计划树 物理优化：逻辑计划树到物理执行计划 经过词法和语法分析，SQL语句可以转化为抽象语法树，这一部分是编译原理课程的主要内容，期间不需要考虑数据库系统的设计和底层存储结构等任何与数据库系统实现相关的内容。所以这一部分不作为本课程关注的重点。根据我们所给出的语法文件，直接利用antlr的访问者模式可以比较轻松地完成这一步转化工作。 数据库解析器的特色在于其抽象语法树的后续处理过程，与编译器和解释器不同，此处不会结合系统和虚拟机特性转化为某种编码格式，而是需要结合数据库的一些统计信息和存储结构，在可能面临的很多种执行方案中规划出一套相对较优的实际物理执行计划并传递给执行器完成这一工作。这一部分包含了逻辑优化和物理优化两个过程，这一部分将成为各位同学思考的重点。 last update at: 8/25/2021, 10:00:52 author: 董昊文 var discussion = document.getElementById('my-comment'); var script = document.createElement('script'); script.src = 'https://utteranc.es/client.js'; script.setAttribute('repo', 'thu-db/dbs-tutorial'); script.setAttribute('issue-term', \"pathname\"); script.setAttribute('theme', 'github-light'); script.setAttribute('crossorigin', 'anonymous'); discussion.appendChild(script); "},{"url":"chapter-5/5_2_sql.html","title":"SQL简介","level":"1.8.3","keywords":[],"body":"5.2 SQL语法简介 结构化查询语言(Structured Query Language)简称SQL，是一种数据库查询和程序设计语言，用于存取数据以及查询、更新和管理关系数据库系统；同时也是数据库脚本文件的扩展名。SQL是一门 ANSI 的标准计算机语言，用来访问和操作数据库系统。虽然作为一种数据库语言的基准，但是工业界数据库厂商大多都在SQL基准基础之上进行了一定程度的变化和拓展，导致了当今存在了大量不同版本的SQL文法规范。本次实验任务中，同学们仅需要重点关注于SQL语言中有关于数据操作语言（DML）和数据定义语言（DDL）的部分重点文法结构。 所有需要支持的文法已经在sql.g4文件中给出，文法对应的功能可以参阅文法手册。 由于SQL语句转抽象语法树的部分是编译原理课程已经充分研究的内容，所以第一个转化阶段不作为本次实验的重点内容，可以直接基于给出的文法文件利用antlr的访问者模式生成这一部分代码。解析器部分重点的实验内容为逻辑优化和物理优化的过程。 last update at: 8/25/2021, 10:00:52 author: 董昊文 var discussion = document.getElementById('my-comment'); var script = document.createElement('script'); script.src = 'https://utteranc.es/client.js'; script.setAttribute('repo', 'thu-db/dbs-tutorial'); script.setAttribute('issue-term', \"pathname\"); script.setAttribute('theme', 'github-light'); script.setAttribute('crossorigin', 'anonymous'); discussion.appendChild(script); "},{"url":"chapter-5/5_3_logic.html","title":"逻辑优化","level":"1.8.4","keywords":[],"body":"5.3 逻辑优化：抽象语法树到逻辑计划树 查询优化器在逻辑优化阶段主要解决的问题是：如何找出SQL语句的等价变换形式，使SQL执行更高效；一般可以使用代数优化的方式完成这一过程。代数优化是通过关系代数中一些等价变化的方式调整原始的抽象语法树结构，使其变化为执行过程上更为简洁高效的逻辑计划树的形式。主要是一些基于规则的固定转化模式，逻辑优化过程基于如下的经验规则： 尽早进行选择运算，这样可以尽早降低运算数据的规模 合并同表的多个选择和投影运算，减少表的扫描次数 合并投影运算和其他双目运算（笛卡尔积，等值连接，并集差集），减少表的扫描次数 合并选择运算与笛卡尔积，避免直接计算笛卡尔积 提取公共子表达式，重复使用 基于上述的经验规则，常用的变化包括如下几类： 列裁剪：运算过程中仅保留必要的列，忽略其余列，降低数据传输开销。 谓词下推：将查询语句中的过滤表达式计算尽可能下推到距离数据源最近的地方，以尽早完成数据的过滤，进而显著地减少数据传输或计算的开销。 子查询合并：在语义等价条件下，多个子查询可以合并成一个子查询，这样多次表扫描，多次连接减少为单次表扫描和单次连接。 谓词重写：利用一些等价规则将IN、OR、LIKE、BETWEEN、AND等谓词进行等价转化。 条件化简：对于WHERE、HAVING等条件进行化简，例如常量传递和不等式变化等。 last update at: 8/25/2021, 10:00:52 author: 董昊文 var discussion = document.getElementById('my-comment'); var script = document.createElement('script'); script.src = 'https://utteranc.es/client.js'; script.setAttribute('repo', 'thu-db/dbs-tutorial'); script.setAttribute('issue-term', \"pathname\"); script.setAttribute('theme', 'github-light'); script.setAttribute('crossorigin', 'anonymous'); discussion.appendChild(script); "},{"url":"chapter-5/5_4_physic.html","title":"物理优化","level":"1.8.5","keywords":[],"body":"5.4 物理优化：查询计划树到物理执行计划 代数优化改变查询语句中操作的次序和组合，但不涉及底层的存取路径。物理优化就是要选择高效合理的操作算法或存取路径，求得优化的查询计划，达到查询优化的目标。 查询优化器在物理优化阶段，主要解决的问题是： 从可选的单表扫描方式中，挑选什么样的单表扫描方式最优？ 对于两表连接，如何连接最优？ 对于多表连接，哪种连接顺序最优？ 对于多表连接，是否需要对每种连接顺序都探索？如果不全部探索，如何找到一种最优组合？ 可以选择基于规则的启发式优化或基于代价估算的优化。基于规则的启发式算法一般相对简单，优化效果一般但是速度较快，适合于解释执行的系统，查询优化和查询执行同时进行。编译执行的方式则是先进行编译优化后整体执行，查询优化和查询执行分离，此时使用基于代价估算的优化更容易获得更好的优化效果，但是可能会面临执行计划的选择空间很大，优化时间开销过高的问题。而将两者结合，先使用启发式算法限制候选空间，对于候选空间内的方案进行代价估计，这样可以在较短时间内获得一个相对较优的执行计划。 last update at: 8/25/2021, 10:00:52 author: 董昊文 var discussion = document.getElementById('my-comment'); var script = document.createElement('script'); script.src = 'https://utteranc.es/client.js'; script.setAttribute('repo', 'thu-db/dbs-tutorial'); script.setAttribute('issue-term', \"pathname\"); script.setAttribute('theme', 'github-light'); script.setAttribute('crossorigin', 'anonymous'); discussion.appendChild(script); "},{"url":"chapter-5/5_5_interface.html","title":"接口说明","level":"1.8.6","keywords":[],"body":"5.5 对外提供的接口 pa::parse() // 词法语法分析：SQL语句到抽象语法树 pa::logic() // 逻辑优化：抽象语法树到逻辑计划树 pa::physic() // 物理优化：逻辑计划树到物理执行计划 last update at: 8/25/2021, 10:00:52 author: 董昊文 var discussion = document.getElementById('my-comment'); var script = document.createElement('script'); script.src = 'https://utteranc.es/client.js'; script.setAttribute('repo', 'thu-db/dbs-tutorial'); script.setAttribute('issue-term', \"pathname\"); script.setAttribute('theme', 'github-light'); script.setAttribute('crossorigin', 'anonymous'); discussion.appendChild(script); "}]
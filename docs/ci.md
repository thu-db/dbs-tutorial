# CI 说明

CI（Continuous Integration，持续集成）是指软件发布流程的构建和单元测试阶段，GitLab、GitHub 等常见的基于 Git 的集成软件开发平台都带有类似的功能，我们将基于清华大学部署的 GitLab 的 CI 完成实验的自动化测试。

截止2023年秋我们实际上使用的是集成测试而非单元测试，它并不能让你的实验每完成一部分后便进行测试，它只能在你将整个实验几大模块都完成后基于SQL的执行情况进行功能性测试。


!!! abstract "激励机制"

    如果你反馈了 CI 漏洞、测例错误、评测器逻辑错误等，甚至提了 PR，助教将根据贡献程度给同一问题的第一个提出者大作业加分，加分会在学期末进行汇总，至多累计（按大作业满分100计算意义下的）5分。


## 1. 使用说明

我们会将分组DDL设在退课第一阶段结束后不久，分组DDL后开放仓库创建，每个组只能由组长创建一个仓库。注意如果你们分组已经非常明确，则完全可以在那之前开始完成实验，分发仓库后再将代码全部放入其中即可。

由于测例中有必做内容也有选做内容，且测例之间可能存在明显的依赖关系，因此你可以通过设置相关 flag 变量的方法来约束 CI 进行的测试，从而使得你在完成部分测试时也能看到 CI 通过的✔️标志，同时也能有效避免无效的 CI 时间。

TODO：确定测例后在这里放测例的依赖关系图。

!!! info "开发顺序"

    尽管实验文档是按照从下而上的顺序编写的，但是这个顺序可能并不符合敏捷开发的工程实践，相比之下你或许会希望快速完成整个框架，逐步通过部分测试以渐渐增长测试分数，那么你可以依据测例的依赖关系来决定你的功能实现顺序。

TODO：在分发仓库前于此处填写设置测试内容的flag相关说明。

在你通过（部分或全部） CI 测例后，你可以在 CI 输出中看到自己的分数。我们通过教学实验平台进行了分数汇总，这里会保留你的最高成绩作为最终成绩，你可以前往平台查看。

TODO：在跟教学实验平台对接完成后补充平台链接以及可能的截图示例。

## 2. 运行要求

CI 运行时会在命令行参数给出 `-b` 选项，给程序的输入为多行 SQL 语句，每一行一定是一个完整的 `;` 结尾的 SQL 语句，输出格式见 [0.3 前端约定](./chapter-0/0-3-frontend.md) 相关内容。

考虑到往年部分同学采用将数据全部导入内存的作弊方法，以及我们的数据库系统很多细节设计都是为了解决内存高性能低容量与磁盘低性能高容量之间的矛盾，我们对 CI 运行时的资源进行了限制，我们限制如下：

- 时间：<3600s
- 内存：<512MB
- 硬盘：10GB
- CPU核数：1

注意这里的控制并非是精确控制，不像 DSA 的 OJ，在数据库这样的大项目里精确控制时间与空间是几乎不可能的，你需要合理地估算。同时时间和内存的限制包含了评测器消耗资源，因此都加了 "<"，评测器的资源消耗理应在资源限制的50%以内，**你实际上被期望使用的时空资源是上述数据的一半**。

就时间而言，为了践行老师所说的“不卡时间”的准则，助教使用 Python 作为标程，确定 Python 版数据库能在规定时间内通过测试，而传统的数据库引擎通常用 C++ 编写，在复杂度、缓存等技术使用无误的情况下理应不会存在性能瓶颈。另一方面，实验推荐使用 C++ 完成，因此除非你对自己的 Python 性能优化很有把握，否则不建议使用 Python 完成实验。

内存上推荐你使用 128MB 空间用作页式文件系统的缓存页，严格限制其他部分的内存应该在某个约束之内。理想情况下其他部分应采用 O(1) 的额外内存，当然严格限制 O(1) 会为你编程带来不必要的困难，因此在此约定所有查询结果不超过 32MB（按整数、浮点数均8字节，字符串为实际长度+1字节进行封底估算）。如果你计划完成聚合查询的选做，那么你或许应该谨慎考虑是否要将所有数据读入内存后再进行聚合操作。

这里举一个内存估算的例子，附件提供的C++页式文件系统为缓存准备了 CAP=MOD=6k 个槽位，为了维护结构信息一次开了 CAP 若干倍个整数，但这部分是可以忽略的小量，即便开了 10 倍的整数，也不过是 $6000 * 40B / 1024 / 1024 = 0.23MB$，它的主要内存消耗在于后面动态分配的 CAP 个页，每页 8192 字节，因此它的主要内存消耗约为 $6000 * 8192B / 1024 / 1024 = 47MB$。

CPU 核数限制 1 则是提示不必使用并行加速等方法来卷性能。

硬盘空间的约束通常用不上，这只是为了防止你的程序出现死循环输出等BUG而给的限制，实际上我们的数据总量通常在1GB以内，即便你用了一些辅助空间也远不会用到10GB——除非你滥用 append only 模式、留了大量 Log 并且从来不进行空间回收。

TODO：蹲一个真的把空间用超了的例子，在这里“公开处刑”。

注意评测机的空间一般来说可以和任意一个 Linux 文件系统一样可以任意读写，但是原则上你应该只操作 `./` 路径下的空间，例如将数据存储在 `./data` 下是一个很好的选择。另外这部分空间会在评测结束后便清理掉，因此你不能指望助教提供你的程序在评测时生成的数据以协助你DEBUG。

## 3. 本地测试

CI 所用的测例均为公开测例，评测器用 Python 编写，同学们应该可以比较容易地在本地运行，因此建议在本地通过测试后再进行 CI 测试，以防无效的 CI 阻塞评测进度。这里强烈建议大家将用于开发的分支和用于提交到 CI 的分支区分开，作为避免滥用 CI 的防呆法，我们在初始的 CI 配置了设置了只有名为 `ci` 的分支 push 后会自动运行 CI，其他分支的 push 需要手动启动 CI。

!!!warn "Windows 支持问题"

    由于 Windows 系统底层与MacOS、Linux的固有差异，一些进程级的操作在两边会有所差异，尽管助教已经尽量修复了这些问题，目前仍然未能解决的遗留问题，如果同学们有解决办法欢迎积极贡献。
    
    例如 Windows 下在 read 子进程的 stdout 时无法用 ++ctrl+c++ 为父进程抛出 `KeyboardInterrupedt`，这可能用在你发现自己的数据库运行测例时太长时间无响应而想强行终止评测的情况，由于这一问题你可能只好直接关闭运行评测器的终端来强制终止进程。 

TODO: 完成 Checker 后在此补充本地运行评测器的方法。


## 4. 测例格式

尽管理论上你可以在完全不了解测例的格式甚至内容的情况下写出一个符合要求的 DBMS，从而直接通过测例，但相信多数同学还是会在实验过程中遇到测例未通过的情况，或者希望自行构造一些测例来辅助 DEBUG，甚至评测器本身也会存在一些 BUG，因此在这里解释一下测例的格式。

### 4.1 输入文件

测例的输入文件是 `.sql` 后缀的 SQL 文件，在文件头部用 SQL 注释语法标记了一些信息，它们定义了一些简易的键值对信息，用 SQL 单行注释符号 `--` 开头，在一个空格后追加 `@` 和键名，然后用 `:` 和一个空格隔开后面的值内容，下面是一个例子：

```SQL
-- @Name: system
-- @Depends: init
-- @Description: Check basic database-level operation
-- @Score: 5
```

依次可以看到：

- 这个测例的名称为 `system`
- 该测例依赖另一个测例 `init`，这意味着只有 `init` 成功执行后 `system` 才会被执行，否则会放弃执行 `system`；如果存在多个依赖，则用空格隔开，例如 `-- @Depends: init init-2 init-3`
- 对该测例的描述，主要用于标注测例的意图
- 通过该测例可以获得5分

注意理论上这些标记信息应该在文件头部，先后顺序不重要，但每个信息只能出现一次；不在文件头部或者重复信息属于未定义行为。

!!! warning "未定义行为"

    未定义行为的表现可能会随着评测器的升级而改变，例如在上面的例子中如果同一个信息出现两次，有可能是第一次的生效，有可能是第二次的生效，也有可能评测器报错，这取决于评测器的具体实现。

输入文件后面则是正常的 SQL 语句，每一行都是一个完整的以 `;` 结尾的一个 SQL 语句，对应文法文件的 `statement`，不会出现用 `;` 隔开的多个语句的情况。空行和 `--` 开头的注释行会被忽略。

### 4.2 输出文件

输出文件也即测例的答案，但是注意 SQL 的答案和常规的 DSA OJ 不同，可以认为它充满了 Special Judge，它的行序与列序有时候是有序的，有时候是无序的（详见[《0.3 前端约定》](./chapter-0/0-3-frontend.md)一节），因此我们需要带有标注语法的输出文件格式来标明这些信息。

输出文件是助教自定义的 `.ans` 后缀的文本文件。它由一些 `@` 打头的标记信息（下称 flag）、纯文本的答案和用于增强可读性的空行（除了答案区域外，空行可以任意添加）组成。一个答案的例子如下：

```
@SQL: DESC TBL;
@DESC
@BEGIN
Field,Type,Null,Default
a,INT,NO,NULL
b,VARCHAR(16),NO,NULL
c,FLOAT,NO,NULL
@END
```

目前实现的 flag 说明如下：

- `@SQL:` 说明了它在测例文件中对应的 SQL 语句，仅用于维护方便，评测器不会用到这一信息
- `@DESC` 说明了这是一个 `DESC <table>` 语句，这一语句很特殊，因为它除了需要输出一张表外还需要额外输出其他信息，因此需要特别的 flag 标记和解析器来处理，如果不是这样的语句则不需要写 `@DESC`
- `@BEGIN` 与 `@END` 之间的若干行是 SQL 预计所期望的输出文本，注意这里的 `DESC` 恰好没有下面的约束信息（即表 `TBL` 没有创建任何约束），所以下面的内容被省略了，表与约束之间的一个空行也被省略了，加上它不影响正确性。注意 `@BEGIN` 与 `@END` 必须放在一个 SQL 语句对应的答案的最后，它之后的 flag 会被视为下一个 SQL 的答案的 flag。在最后一个 `@END` 后面添加标记信息属于未定义行为。
- 由于 `SELECT *` 不需要考虑列序，所以同样需要一个 flag，`@STAR` 用于标记这个信息。
- 如果需要按行排序，则需要用 `@ORDER: ` 标记排序字段，注意冒号后有一个空格，如果有多个排序关键字则将字段名用空格隔开。此外排序默认是降序排序，如果是升序排序则用 `@ASC` 标记。通常 SQL 语法要求缺省情况下是 `ASC` 升序排序，与此处的约定相反，需要特别注意。

!!! Note "DESC? DESC!"

    缺省为降序显然不合常理，这主要是因为 SQL 里通常缺省为升序 `ASC`，降序 `DESC` 需要显式标记，而 `DESC` 已经被 `DESC <table>` 抢占了，并且很难想到合适的替代词汇，所以只好将 `ASC` 设定为需要显式给出。

在排序上有一个无法绕过的问题：假设数据按列 `C` 排序，那么对 `C` 字段相同的两条记录来说它们的顺序可以是任意的。但是查询语句有可能并没有 `SELECT` 出 `C`，此时评测器不可能判断程序是否正确给出了顺序，在这种情况下只能放弃检查有序性。
在我们的测例里测试 `ORDER BY` 的地方会避免这种情况，保证 `SELECT` 了所有排序关键字，如果你自己构造测例需要留意这一点。
